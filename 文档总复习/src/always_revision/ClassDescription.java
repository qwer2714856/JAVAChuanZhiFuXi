/**
 * 面向对象
 * 本期介绍java的面向对象概念
 * 
 * 万物皆对象
 * 类和对象的关系
 * 程序中，类是对象抽象出来的，而对象又是类实例化而来的，两者相辅相成。
 * 
 * 面向对象的特征
 * 1.多态   
 * 2.继承
 * 3.封装
 * 开发过程要把自己想成 上帝，在程序中你主宰一切，控制对象之间的调度。
 * 设计的过程就维护对象之间的关系。
 * 
 * 开发过程，以及设计过程
 * 
 * 对象中成员属性的默认值
 * byte 0
 * short 0
 * int 0
 * long 0
 * char \u0000
 * boolean false
 * double 0.0d
 * float 0.0f
 * 
 * 引用数据类型的都是null
 * 例如
 * String str; 默认null
 * Car c; null
 * int []a;null
 * 
 * 但是局部变量必须赋初值才能使用，成员不需要赋初值就可以用例如
 * int a;
 * 
 * a += 1;报错
 * 
 * Car a = new Car();
 * a.a+=1;不报错
 * 
 * 
 * 匿名对象
 * 主要用于
 * 1.只调用一次方法。
 * 2.作为实参的传递
 * 
 * new Car().run();
 * 
 * new Factory(new Car());
 * Factory(Car car);
 * 
 * 封装
 * 好处 
 * 1.对象细节的隐藏 
 * 2.使用方便
 * 3.对数据的保护性
 * 
 * 构造函数
 * 如果一个类，没有自定义构造函数，那么jvm会自动的添加一个无参构造函数。
 * 如果一个类,定义了构造函数那么jvm就不会自动添加这个无参的构造函数。
 * 
 * 构造函数和一般函数的区别
 * 1.函数是对象的方法，构造函数是对象初始化用的。
 * 2.函数是对象调用的，构造函数是JVM调用的对象一产生自动调用。
 * 3.函数可以调用多次，构造函数只有创建对象时候才调用。
 * 4.构造函数命名和类名同，函数只要符合命名规则即可。
 * 5.构造函数没有返回值。
 * 
 * 构造函数的注意细节
 * 1.当类没有定义构造函数，jvm自动建一个无参空的构造方法，有就不建了。（通过javap可以验证）
 * 2.构造方法可以重载。
 * 
 * 构造代码块
 * class A{
 * 	int a = 1;
 * 	{
 * 		System.out.println(a); //如果a放到构造代码块下面就无法读取a的值
 * 		say();
 * 	}
 * }
 * 代码只要实例化就会自动调用say这个方法，不必再每个构造方法中加入。
 * 
 * 构造代码块作用
 * 1.对象创建调用，优先级高于构造函数。
 * 2.与构造函数区别，构造代码块是给所有对象初始化，构造函数是为每个对象初始化。
 * 3.它就是将所有的构造方法要做的事情提取出来放到这。
 * 
 * this 关键字
 * 作用就是当局部变量和成员变量重名用this可以引用成员变量。
 * 用this 调用构造方法this(a) this(a,b) 可以这么调用构造方法。
 * 构造方法相互调用会造成编译错误。
 * this 只用在非静态里面。
 * 构造函数相互调用，this()必须放在第一句否则编译报错。
 * 
 * 
 * static
 * 静态修饰的变量放在数据共享区里面，静态的方法还是以字节码的形式在方法区里面待着，如果使用将会调到栈内存执行完了就销毁了。
 * 非静态必须通过实例化，通过引用对象来调用。
 * 静态的通过类名来调用，也可通过对象引用来调用。
 * 
 * ！静态的不可以使用非静态的成员。
 * ！但是非静态的可以使用静态的成员。
 * !静态之间可以相互调用 静态方法没有this super
 * 
 * 为什么静态的不能访问非静态的？
 * 因为静态的数据是在共享区中的，然而静态方法可以通过类名直接调用，这样如果没有实例化，对象的非静态数据无法初始化。
 * 通过类名.静态方法 如果调用的非静态方法那就报错，因为编译觉得非静态的方法里面可能会引用非静态成员变量。
 * 静态数据是类被从硬盘读进方法区就进入到数据共享区了，而非静态数据是创建完对象才会有的。
 * 
 * static 优先于对象的存在
 * 
 * ====		====
 * 栈→		堆
 * ====		====
 * ↑
 * =============
 * 方法区	========
 * 		数据共享区
 * 		========
 * =============
 * ↑
 * ==============
 * 	硬盘
 * ==============
 * 
 * 静态代码块
 * 当使用类，被加到方法区的时候，调用一次其它无论是类调用方法还是实例化都不在执行
 * ClassDescription.say 类被使用调用一次
 * new ClassDescription() 不会再执行了因为类已经尽到方法区了
 * 
 * //ClassDescription.say
 * new ClassDescription() 因为这个是第一次使用所以被加入到方法区的时候自然调用一次。
 * 
 * 静态代码块和构造代码块区别
 * 静态代码块是类被第一次使用，从硬盘进入方法区的时候调用，这个只有一次调用机会就是刚进方法区,而且它的优先级非常高，当定义在主函数类上高于主函数。
 *  
 * 构造代码块是类被实例化调用，这个只要类被实例化就可以调用。
 * 
 * 不管是静态代码段也好构造代码段也好，只要想使用类的成员变量就必须为与成员变量下面定义。
 * 
 * static 的特点
 * 1.随着类的加载而创建，随着类的销毁而销毁，生命周期长。
 * 2.优先级很高，静态的是优先于对象的
 * 3.数据共享区的数据被所有实例所共享。
 * 4.可以直接用类名调用
 * 
 * 静态变量和实例变量的区别
 * 1 存放位置
 * 静态变量在静态数据共享区
 * 对象的变量在堆
 * 2 生命周期
 * 静态变量随着类的销毁而销毁
 * 对象变量随着对象的销毁而销毁
 * 
 * 静态的优点
 * 1数据共享
 * 2节省空间
 * 3类名调用
 * 
 * 缺点
 * 生命周期太长
 * 有自己的局限性
 * 
 * 什么时候定义静态变量
 * 需要共享的数据
 * 
 * 什么时候使用静态函数
 * 静态函数么有调用非静态变量，而且需要通过类名直接访问静态函数，有点不需要实例化就可以调用。
 * 
 * 静态的应用
 * 定义工具类，不需要对象实例化使用的。
 * 
 * main方法的解析
 * 1.主函数是静态的
 * 2.主函数是作为入口，可以被jvm识别
 * 3.主函数定义
 * 	 public 必须要最大
 * 	 static 随着类的加载就存在了，因为JVM不实例化所以这么定义。
 * 	 void 主函数没有返回值
 * 	 main jvm唯一识别的入口名字，不是关键字。
 * 
 * 	 String [] args 是dos下的参数列表 java ... a b c 都保存在args里面 如果传入参数相当于 jvm 相当做了一个 new String[]{a,b,c}
 * 	 
 * 继承
 * 类和类之间的关系
 * is a 关系 学生和人。 
 * has a 整体和部分。
 * 
 * class 球场{
 * 	private 球场的座位 a = null;
 * }
 * 球场和球场的座位就是整体和部分的关系。 has a 关系
 * 
 * class Person{
 * 
 * }
 * 
 * class work extends Persion{
 * 
 * } 这个就是继承的关系，工人继承自人。is a 
 * 
 * is a 解释 什么是一个什么
 * has a  什么里面有什么
 * 
 * 继承的细节
 * 父类中除了构造，所有的东西都会继承下来，包括private(隐式继承)不能由子类调用，只能由父类方法调用。包括静态非静态。 父类的静态成员是可以通过子类类名调用的
 * 
 * 如何使用继承
 * 不能为了继承而用继承，一定要出现is a的关系。
 * 狗和人类有共同方法 不能为了简写让狗继承人，狗和人没关系。
 * 使用继承是建立在is a的关系上的
 * 
 * java是单继承的。
 * 
 * super 关键字
 * 指向的是父类
 * 主要用于子类调用父类的方法成员，如果子类重写父类的方法，还想调父类原来的方法就只能在子类用super.父类方法。 调用父类的构造super();
 * 
 * super和this很像
 * this指向当前对象，super指向父辈对象。
 * 如果使用children 那么继承的父类也被加载到内存。
 * 注意在使用继承的时候，如果子类继承了父类，实例化子类那么默认是会调用父类的无参构造方法相当于super()。 
 * 创建子类对象的时候也创建了父类对象this 子类 super父类实例，但是这个父类实例只能在子类中使用。
 * 子类的构造函数默认第一行会调用父类的构造super();当然如果你手动写上了就用你的。
 * 但是如果父类没有构造方法就直接报错了。 super() this();不能同时放到第一行，但这两个必须都在第一行。
 * 
 * Object 是所有类的父类 普通类也可用super 没有继承关系的类如果用了super代表的是Object。
 * 
 * 
 * 方法重写
 * 重写的细节
 * 1.必须是字符类关系，子类重写父类
 * 2.函数名，形参列表相同
 * 3.子类重写父类的时候修饰权限必须大于等于父类，例如父类protected那么子类只能是protected或public
 * 4.子类的返回值类型必须是父类的子类或者和父类一样。
 * 5.抛出异常，子类不能抛出比父类大的异常，如果父类没异常子类不允许抛出异常.
 * 
 * 子类的对象调用方法先使用this的然后使用super最后没有找到就报错，就近原则。
 * 
 * 重载 与 重写的不同
 * 重载所有函数必须放在同一个类中，函数名相同，形参列表不同
 * 重写要满足五个需求。
 * 
 * instanceof 
 * instanceof 是比较运算符中的。
 * 
 * Person extends Ps
 * Person p = new Person();
 * p instanceof Persion true
 * p instanceof Ps true
 * 
 * 只要是继承关系，实现关系，类实例关系，都返回true,这么讲有关系就返回true.
 * 
 * 
 * final
 * 主要用于修改 类 成员,形参
 * 被final修饰的不能够再次赋值，重写，以及继承。
 * 如果修饰的是形参
 * 那么这个形参在方法中不能二次赋值，如果形参是引用类型的不能够在次赋值引用给他。
 * final 修饰成员变量的时候必须赋初值，因为只有一次的赋值机会。
 * 
 * final 修饰普通类型不能换值
 * final 修饰引用的数据类型不能换另外一个对象引用。
 * 
 * 一般和static 结合使用作为常量
 */
package always_revision;

/**
 * @author www.23.com
 *
 */
public class ClassDescription {
	static int niunifa = 1;
	static {
		System.out.println(niunifa);
	}
	{
		System.out.println("haha2");
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("main run");
		/*System.out.println(new Car("",1));
		ClassDescription.say();
		new ClassDescription();
		new ClassDescription();*/
		
	}
	public static void say(){}
	public void say1(){
	
	}
}

class Car{
	static {
		System.out.println('s');
	}
	private String color;
	public char c;
	int a ;
	private int Lt = 2;
	public Car(String color, int lt) {
		super();
		this.color = color;
		Lt = lt;
	}
	void run(){
		System.out.println("the car run");
	}
	{
		System.out.println(this.Lt);
	}
	public Car(String color, char c, int a, int lt) { 	
		this.color = color;
		this.c = c;
		this.a = a;
		Lt = lt;
	}
	public Car(){};
}

interface l{}
 